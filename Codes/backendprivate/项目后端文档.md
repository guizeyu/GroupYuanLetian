# 后端开发文档

## 张稷平 吴可非

### 1.技术栈

后端和数据库采用了springboot+mysql , orm框架采用了spring-jpa

### 2.实现

#### 2.1身份认证

采用了jwt技术。登陆时会在响应里返回token。由于spring-security做的事情太多了，我们并不喜欢，所以我们自己写了jwt service。它可以从配置文件读取人工设置的有效时间，然后调用alibaba fastjson 和 hutool工具包里的base64编码 sha256签名方法 生成token。

#### 2.2多人互动场景和websocket通信

使用了springboot带的websocket功能，来完成多人交互功能。

用户进入场景的时候会发起websocket连接，接着通过websocket连接发各种控制命令和消息

后端有一个单例维护着所有的websocket连接，并且所有修改它的操作都是被锁保护、线程安全的，所有操作都需要先把锁锁上，做完之后释放锁。

为了防止客户端死机，不能正确关闭tcp连接，服务端会维护大量已经死了的连接的情况，我们设计了客户端每隔2.5秒心跳一次，10秒没心跳的客户端会被服务端移出服务列表，也就是，强制关闭websocket连接

#### 2.3命令模式

在websocket通信中，每个消息都是一个json串，它必须包含"command"属性。后端为每种command注册了一个处理程序。每次有消息来的时候，会先解析这是什么命令，然后调用对应的处理程序。

例如，如果是private_chat，那我们会把它发给对应的玩家

如果是movement public_chat，我们会向房间里的所有人广播

### 3.代码的一些优点和设计模式

#### 3.1命令模式

websocket通信中使用命令模式，为每个命令单独注册一个处理程序。如果有功能的增加，那么可以新设置一个命令处理程序，不会破坏也不用改动原有代码，可扩展性很强。

#### 3.2装饰器模式

心跳在我们的代码中是一个装饰器。我们认为，除了hearbeat命令之外，其它所有命令，在我们看来，也能证明这个websocket连接还活着。因此，我们把心跳设置为了一个装饰器。所有命令的处理程序都可以被心跳装饰器包装，而运行时被包装的处理程序会先执行心跳处理（也就是记录当前时间为该连接最终活跃时间），在执行正常处理程序的功能。这样，心跳处理的代码得到了有效的复用。

![wrapper](.\doc_img\wrapper.jpg)

#### 3.3策略模式

![strategy](.\doc_img\strategy.jpg)在项目中，很多地方我们需要实现对房间内每个人广播消息的功能（例如：移动、房间聊天）。在后端实现的时候，维护所有用户连接的类需要锁进行保护，而此时正常的方法实现广播消息的功能会特别困难：需要获取维护连接的类的锁，然后执行操作，然后释放掉。因此，我们采用了策略模式：在维护连接的类中提供了一个forEachInRoom方法，它需要接受房间号、对每个用户要做什么事情的策略作为参数。

#### 3.4配置读取代替硬编码

![task](.\doc_img\clear_task.jpg)

我们 项目中尽可能多地使用了配置文件读取的功能。例如，清理不心跳用户（这很可能是由于客户端死机，前端未能正常关闭导致的）的定时任务，已经没有心跳多久就会被清掉的时间是从配置文件中读取来的。